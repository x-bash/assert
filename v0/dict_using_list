# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao

: <<COMMENT
1. If bash 4, using bash 4 associate arary
2. If not bash 4, using variable definition for implementation

if [[ "${BASH_VERSION}" == 3* ]]; then
    # Using Self defined dict
else
    # Using Associative Array
fi
COMMENT

xrc std/list
xrc std/str

dict.make(){
    list.make "$@"
}

dict.new(){
    oo.create_new_function dict "$@"
}

dict.free(){
    list.free
}

dict.has(){
    dict.get "$1" > /dev/null
}

dict.size(){
    list.size
}

dict.isempty(){
    list.isempty
}

dict.get(){
    local key=${1:?Provide key}
    local keyecode
    keyecode=$(str.base64 "$key")
    for i in $(list.print); do
        local k
        k=$(echo "$i" | cut -d ':' -f 1)
        if [ "$k" = "$keyecode" ]; then
            local v
            v=$(echo "$i" | cut -d ':' -f 2)
            str.unbase64 "$v"
            return 0
        fi
    done
    return 1
}

dict.put(){
    local key
    key="$(str.base64 "${1:?Provide key}")"
    local value
    value="$(str.base64 "${2:?Provide value}")"
    dict.remove "$1"
    # echo "$key":"$value"
    list.push "$key:$value"
}

# give key
dict.remove(){
    local key="${1:?Key}"
    local key_base
    key_base="$(str.base64 "${1:?Provide key}")"
    local idx=0
    for i in $(list.print); do
        local k
        k=$(echo -n "$i" | cut -d ':' -f 1)
        if [ "$k" = "$key_base" ]; then
            # echo remove $idx
            list.remove "$idx"
            return 0
        fi
        (( idx=idx+1 ))
    done
    return 1
}

# TODO: add key/value filter in arguments or enviroments
# shellcheck disable=SC2120
dict.print(){
    local key_filter="$1" value_filter="$2"
    [ "$1" = "-" ] && key_filter=""
    [ "$2" = "-" ] && value_filter=""

    local k v
    local sep=${DICT_PRINT_SEP:-" = "}
    for i in $(list.print); do
        k=$(echo -n "$i" | cut -d ':' -f 1)
        v=$(echo -n "$i" | cut -d ':' -f 2)

        k=$(str.unbase64 "$k")
        v=$(str.unbase64 "$v")

        # using regex
        # [ -n "$key_filter" ] && [[ ! "$k" =~ $key_filter ]] && continue
        # [ -n "$value_filter" ] && [[ ! "$v" =~ $value_filter ]] && continue

        # Using glob. So no quote for that
        # shellcheck disable=SC2053
        [ -n "$key_filter" ] && [[ ! "$k" == $key_filter ]] && continue
        # shellcheck disable=SC2053
        [ -n "$value_filter" ] && [[ ! "$v" == $value_filter ]] && continue

        echo -e "$k${sep}$v"
    done
}

dict.dump(){
    if [ $# -eq 0 ]; then
        list.print
        return 0
    fi
    list.print | tee "$@"
}

dict.load(){
    local name=${1?:Provide name}
    shift
    dict.make "$name"

    if [ $# -eq 0 ]; then
        while read -r s; do
            list.push "$s"
        done
        return 0
    fi

    while read -r s; do
        list.push "$s"
    done <"$1"
}

dict.__toJSON(){
    local first=0
    local k v

    local IFS=$'\n'
    # Using consider using environment.
    local PARSE_KEY_STR="$*"

    while :; do
        read -r k || break
        read -r v || break

        if [ "$first" -eq 0 ]; then
            printf "{\n"
            first=1
        else
            printf ',\n'
        fi

        if echo "$PARSE_KEY_STR" | grep -q "$k"; then
            # TODO: using float
            if [[ "$v" =~ ^[1-9]+([0-9])*$ ]] || [ "$v" = true ] || [ "$v" = false ]; then
                printf '  "%s": %s' "$k" "$v"
                continue
            fi
        fi

        printf '  "%s": "%s"' "$k" "$v"
    done
    [ $first -ne 0 ] && printf "\n}"
}

dict.toJSON(){
    # local sep=${DICT_PRINT_SEP:-" = "}
    # local IFS=$'\n'
    # list.print 1>| while read -r line; do
    #     echo "$line" | cut -d ':' -f 1 | str.unbase64
    #     echo ""
    #     echo "$line" | cut -d ':' -f 2 | str.unbase64
    #     echo ""
    # done | dict.__toJSON
    # local DICT_PRINT_SEP="\n"
    # dict.print | dict.__toJSON
    DICT_PRINT_SEP="\n" dict.print | dict.__toJSON "$@"

    # for i in $(list.print); do
    #     echo -n "$i" | cut -d ':' -f 1 | str.unbase64
    #     echo -n "$i" | cut -d ':' -f 2 | str.unbase64
    # done | dict.__toJSON
}

# Simply json stringify
# dict.__toJSON(){
#     printf "{\n"
#     local first=0
#     local k v
#     for i in $(list.print); do

#         if [ "$first" -eq 0 ]; then
#             first=1
#         else
#             printf ',\n'
#         fi

#         k=$(echo -n "$i" | cut -d ':' -f 1)
#         v=$(echo -n "$i" | cut -d ':' -f 2)

#         printf '  "%s": "%s"' "$(str.unbase64 "$k")" "$(str.unbase64 "$v")"
#     done
#     printf "\n}"
# }
